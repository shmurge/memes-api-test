{"uid":"d11224925a9493ce","name":"Создать новый мем","fullName":"tests.test_memes_api.TestMemes#test_create_meme","historyId":"5006271f34a7538ee2e360b1873e52ac","time":{"start":1766656005770,"stop":1766656006114,"duration":344},"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)","statusTrace":"self = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n../local/lib/python3.11/site-packages/requests/models.py:976: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../local/lib/python3.11/json/__init__.py:346: in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n../local/lib/python3.11/json/decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7f5c85ed4e50>\ns = '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\\n<title>500 Internal Server Error</title>\\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\\n'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/json/decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_memes_api.TestMemes object at 0x7f5c84047d50>\nnew_meme = RequestCreateMemeModel(text='Smile seem road run decide fly street cause. Rock subject about. Treat prove series.\\nLea...ice.', 'Long.', 'Become.'], info={'colors': ['#efbca0', '#1cbf32'], 'names': ['Daniel Hines', 'Christopher Mcdonald']})\n\n    @pytest.mark.test\n    @allure.feature('Создание мема')\n    @allure.title('Создать новый мем')\n    @pytest.mark.high\n    @pytest.mark.parametrize('new_meme', [payload.create_meme,\n                                          payload.create_meme,\n                                          payload.create_meme])\n    def test_create_meme(self, new_meme):\n>       create_meme_resp = self.memes_api.create_meme(new_meme)\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests/test_memes_api.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \napi_client/memes_api/memes_api.py:30: in create_meme\n    self.assertions.check_status_code_is_200(resp)\nassertions/base_assertions.py:10: in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"_session_faker","time":{"start":1766656005428,"stop":1766656005430,"duration":2},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0},{"name":"check_token","time":{"start":1766656005430,"stop":1766656005769,"duration":339},"status":"passed","steps":[{"name":"Проверка апи токена","time":{"start":1766656005430,"stop":1766656005769,"duration":339},"status":"passed","steps":[{"name":"Проверка состояния токена","time":{"start":1766656005431,"stop":1766656005769,"duration":338},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0}],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":1,"shouldDisplayMessage":false,"attachmentsCount":0}],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":2,"shouldDisplayMessage":false,"attachmentsCount":0},{"name":"_xunit_setup_method_fixture_TestMemes","time":{"start":1766656005769,"stop":1766656005769,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0}],"testStage":{"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)","statusTrace":"self = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n../local/lib/python3.11/site-packages/requests/models.py:976: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../local/lib/python3.11/json/__init__.py:346: in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n../local/lib/python3.11/json/decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7f5c85ed4e50>\ns = '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\\n<title>500 Internal Server Error</title>\\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\\n'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/json/decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_memes_api.TestMemes object at 0x7f5c84047d50>\nnew_meme = RequestCreateMemeModel(text='Smile seem road run decide fly street cause. Rock subject about. Treat prove series.\\nLea...ice.', 'Long.', 'Become.'], info={'colors': ['#efbca0', '#1cbf32'], 'names': ['Daniel Hines', 'Christopher Mcdonald']})\n\n    @pytest.mark.test\n    @allure.feature('Создание мема')\n    @allure.title('Создать новый мем')\n    @pytest.mark.high\n    @pytest.mark.parametrize('new_meme', [payload.create_meme,\n                                          payload.create_meme,\n                                          payload.create_meme])\n    def test_create_meme(self, new_meme):\n>       create_meme_resp = self.memes_api.create_meme(new_meme)\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests/test_memes_api.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \napi_client/memes_api/memes_api.py:30: in create_meme\n    self.assertions.check_status_code_is_200(resp)\nassertions/base_assertions.py:10: in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError","steps":[{"name":"Создать мем","time":{"start":1766656005770,"stop":1766656006114,"duration":344},"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n","statusTrace":"  File \"/usr/workspace/api_client/memes_api/memes_api.py\", line 30, in create_meme\n    self.assertions.check_status_code_is_200(resp)\n  File \"/usr/workspace/assertions/base_assertions.py\", line 10, in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.11/site-packages/requests/models.py\", line 980, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n","steps":[{"name":"Статус-код 200","time":{"start":1766656006113,"stop":1766656006113,"duration":0},"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n","statusTrace":"  File \"/usr/workspace/assertions/base_assertions.py\", line 10, in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.11/site-packages/requests/models.py\", line 980, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n","steps":[],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":true,"attachmentsCount":0}],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":1,"shouldDisplayMessage":false,"attachmentsCount":0}],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":2,"shouldDisplayMessage":true,"attachmentsCount":0},"afterStages":[{"name":"_xunit_setup_method_fixture_TestMemes::0","time":{"start":1766656006181,"stop":1766656006181,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0}],"labels":[{"name":"feature","value":"Создание мема"},{"name":"story","value":"API тесты"},{"name":"suite","value":"Мемы"},{"name":"tag","value":"high"},{"name":"tag","value":"test"},{"name":"parentSuite","value":"tests"},{"name":"subSuite","value":"TestMemes"},{"name":"host","value":"7461769141ab"},{"name":"thread","value":"9-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.test_memes_api"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"new_meme","value":"RequestCreateMemeModel(text='Smile seem road run decide fly street cause. Rock subject about. Treat prove series.\\nLeave state customer how our value lawyer. Speak recently rise trouble idea argue. Law myself foreign meet this.', url='http://carrillo.com/', tags=['Nice.', 'Long.', 'Become.'], info={'colors': ['#efbca0', '#1cbf32'], 'names': ['Daniel Hines', 'Christopher Mcdonald']})"}],"links":[],"hidden":true,"retry":true,"extra":{"categories":[],"tags":["high","test"]},"source":"d11224925a9493ce.json","parameterValues":["RequestCreateMemeModel(text='Smile seem road run decide fly street cause. Rock subject about. Treat prove series.\\nLeave state customer how our value lawyer. Speak recently rise trouble idea argue. Law myself foreign meet this.', url='http://carrillo.com/', tags=['Nice.', 'Long.', 'Become.'], info={'colors': ['#efbca0', '#1cbf32'], 'names': ['Daniel Hines', 'Christopher Mcdonald']})"]}