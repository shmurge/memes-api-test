{"uid":"98bfd4548e86c27e","name":"Отредактированный мем должен отображаться в списке мемов","fullName":"tests.test_memes_api.TestMemes#test_updated_meme_should_be_in_memes_list","historyId":"10a1d7abbb5fa37e0a60b432dcbf3da7","time":{"start":1766656009403,"stop":1766656009759,"duration":356},"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)","statusTrace":"self = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n../local/lib/python3.11/site-packages/requests/models.py:976: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../local/lib/python3.11/json/__init__.py:346: in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n../local/lib/python3.11/json/decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7f39e8b852d0>\ns = '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\\n<title>500 Internal Server Error</title>\\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\\n'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/json/decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_memes_api.TestMemes object at 0x7f39e6d28dd0>\npre_update_and_delete_meme = ResponseMemeModel(id=237, info={'names': ['Frederick Ayala', 'Jamie Pope DVM', 'Anita Torres'], 'phone_numbers': ['(56...ay garden staff fine. When learn big stock wonder I get.', updated_by='Aleksei Mishin', url='https://ware-suarez.net/')\n\n    @allure.feature('Изменение мема')\n    @allure.title('Отредактированный мем должен отображаться в списке мемов')\n    @pytest.mark.high\n    def test_updated_meme_should_be_in_memes_list(self, pre_update_and_delete_meme):\n>       response = self.memes_api.get_all_memes()\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests/test_memes_api.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \napi_client/memes_api/memes_api.py:109: in get_all_memes\n    self.assertions.check_status_code_is_200(resp)\nassertions/base_assertions.py:10: in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"_session_faker","time":{"start":1766656005430,"stop":1766656005431,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0},{"name":"check_token","time":{"start":1766656005432,"stop":1766656005769,"duration":337},"status":"passed","steps":[{"name":"Проверка апи токена","time":{"start":1766656005432,"stop":1766656005769,"duration":337},"status":"passed","steps":[{"name":"Проверка состояния токена","time":{"start":1766656005432,"stop":1766656005769,"duration":337},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0}],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":1,"shouldDisplayMessage":false,"attachmentsCount":0}],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":2,"shouldDisplayMessage":false,"attachmentsCount":0},{"name":"pre_update_and_delete_meme","time":{"start":1766656008800,"stop":1766656009403,"duration":603},"status":"passed","steps":[{"name":"Создать мем","time":{"start":1766656008800,"stop":1766656009109,"duration":309},"status":"passed","steps":[{"name":"Статус-код 200","time":{"start":1766656009108,"stop":1766656009108,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0},{"name":"Проверка данных мема","time":{"start":1766656009108,"stop":1766656009108,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0}],"attachments":[{"uid":"2d541e30dfe8418","name":"API Response","source":"2d541e30dfe8418.json","type":"application/json","size":557}],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":2,"shouldDisplayMessage":false,"attachmentsCount":1},{"name":"Изменить мем с id: 237","time":{"start":1766656009110,"stop":1766656009403,"duration":293},"status":"passed","steps":[{"name":"Статус-код 200","time":{"start":1766656009402,"stop":1766656009402,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0}],"attachments":[{"uid":"26f42973db1fdcb8","name":"API Response","source":"26f42973db1fdcb8.json","type":"application/json","size":556}],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":1,"shouldDisplayMessage":false,"attachmentsCount":1}],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":5,"shouldDisplayMessage":false,"attachmentsCount":2},{"name":"_xunit_setup_method_fixture_TestMemes","time":{"start":1766656008800,"stop":1766656008800,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0}],"testStage":{"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)","statusTrace":"self = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n../local/lib/python3.11/site-packages/requests/models.py:976: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../local/lib/python3.11/json/__init__.py:346: in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n../local/lib/python3.11/json/decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7f39e8b852d0>\ns = '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\\n<title>500 Internal Server Error</title>\\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\\n'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/json/decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_memes_api.TestMemes object at 0x7f39e6d28dd0>\npre_update_and_delete_meme = ResponseMemeModel(id=237, info={'names': ['Frederick Ayala', 'Jamie Pope DVM', 'Anita Torres'], 'phone_numbers': ['(56...ay garden staff fine. When learn big stock wonder I get.', updated_by='Aleksei Mishin', url='https://ware-suarez.net/')\n\n    @allure.feature('Изменение мема')\n    @allure.title('Отредактированный мем должен отображаться в списке мемов')\n    @pytest.mark.high\n    def test_updated_meme_should_be_in_memes_list(self, pre_update_and_delete_meme):\n>       response = self.memes_api.get_all_memes()\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests/test_memes_api.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \napi_client/memes_api/memes_api.py:109: in get_all_memes\n    self.assertions.check_status_code_is_200(resp)\nassertions/base_assertions.py:10: in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError","steps":[{"name":"Вернуть все мемы","time":{"start":1766656009403,"stop":1766656009759,"duration":356},"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n","statusTrace":"  File \"/usr/workspace/api_client/memes_api/memes_api.py\", line 109, in get_all_memes\n    self.assertions.check_status_code_is_200(resp)\n  File \"/usr/workspace/assertions/base_assertions.py\", line 10, in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.11/site-packages/requests/models.py\", line 980, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n","steps":[{"name":"Статус-код 200","time":{"start":1766656009758,"stop":1766656009758,"duration":0},"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n","statusTrace":"  File \"/usr/workspace/assertions/base_assertions.py\", line 10, in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.11/site-packages/requests/models.py\", line 980, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n","steps":[],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":true,"attachmentsCount":0}],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":1,"shouldDisplayMessage":false,"attachmentsCount":0}],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":2,"shouldDisplayMessage":true,"attachmentsCount":0},"afterStages":[{"name":"pre_update_and_delete_meme::0","time":{"start":1766656009820,"stop":1766656010113,"duration":293},"status":"passed","steps":[{"name":"Удалить мем с id: 237","time":{"start":1766656009820,"stop":1766656010113,"duration":293},"status":"passed","steps":[{"name":"Статус-код 200","time":{"start":1766656010113,"stop":1766656010113,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0},{"name":"Отображается сообщение об успешном удалении мема","time":{"start":1766656010113,"stop":1766656010113,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0}],"attachments":[{"uid":"1c0396d96431e2e7","name":"API Response","source":"1c0396d96431e2e7.json","type":"application/json","size":39}],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":2,"shouldDisplayMessage":false,"attachmentsCount":1}],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":3,"shouldDisplayMessage":false,"attachmentsCount":1},{"name":"_xunit_setup_method_fixture_TestMemes::0","time":{"start":1766656010114,"stop":1766656010114,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":false,"attachmentsCount":0}],"labels":[{"name":"suite","value":"Мемы"},{"name":"feature","value":"Изменение мема"},{"name":"story","value":"API тесты"},{"name":"tag","value":"high"},{"name":"parentSuite","value":"tests"},{"name":"subSuite","value":"TestMemes"},{"name":"host","value":"7461769141ab"},{"name":"thread","value":"15-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.test_memes_api"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":true,"retry":true,"extra":{"categories":[],"tags":["high"]},"source":"98bfd4548e86c27e.json","parameterValues":[]}