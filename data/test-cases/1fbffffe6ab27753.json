{"uid":"1fbffffe6ab27753","name":"Повторно отредактированный мем должен отображаться в списке мемов","fullName":"tests.test_memes_api.TestMemes#test_re_updated_meme_should_be_in_memes_list","historyId":"b9d0a685aad92b2ed88e30fb90380fba","time":{"start":1766657870255,"stop":1766657870917,"duration":662},"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)","statusTrace":"self = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n../local/lib/python3.11/site-packages/requests/models.py:976: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../local/lib/python3.11/json/__init__.py:346: in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n../local/lib/python3.11/json/decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7f2210ad0e50>\ns = '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\\n<title>500 Internal Server Error</title>\\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\\n'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/json/decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_memes_api.TestMemes object at 0x7f220ec79590>\npre_update_and_delete_meme = ResponseMemeModel(id=261, info={'names': ['Michelle Smith', 'Brianna Parker', 'Andrea Contreras'], 'phone_numbers': ['...ign help. Apply fly range although attention various court.', updated_by='Aleksei Mishin', url='https://phillips.com/')\n\n    @allure.feature('Изменение мема')\n    @allure.title('Повторно отредактированный мем должен отображаться в списке мемов')\n    @pytest.mark.medium\n    def test_re_updated_meme_should_be_in_memes_list(self, pre_update_and_delete_meme):\n        mem_id = pre_update_and_delete_meme.id\n        update_meme_resp = self.memes_api.update_meme(mem_id, payload.update_meme(mem_id))\n>       get_memes_resp = self.memes_api.get_all_memes()\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests/test_memes_api.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \napi_client/memes_api/memes_api.py:109: in get_all_memes\n    self.assertions.check_status_code_is_200(resp)\nassertions/base_assertions.py:10: in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"_session_faker","time":{"start":1766657864373,"stop":1766657864375,"duration":2},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0,"hasContent":false},{"name":"check_token","time":{"start":1766657864375,"stop":1766657864715,"duration":340},"status":"passed","steps":[{"name":"Проверка апи токена","time":{"start":1766657864375,"stop":1766657864715,"duration":340},"status":"passed","steps":[{"name":"Проверка состояния токена","time":{"start":1766657864375,"stop":1766657864714,"duration":339},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0,"hasContent":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":1,"hasContent":true}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":2,"hasContent":true},{"name":"_xunit_setup_method_fixture_TestMemes","time":{"start":1766657869600,"stop":1766657869600,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0,"hasContent":false},{"name":"pre_update_and_delete_meme","time":{"start":1766657869601,"stop":1766657870255,"duration":654},"status":"passed","steps":[{"name":"Создать мем","time":{"start":1766657869601,"stop":1766657869927,"duration":326},"status":"passed","steps":[{"name":"Статус-код 200","time":{"start":1766657869926,"stop":1766657869926,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0,"hasContent":false},{"name":"Проверка данных мема","time":{"start":1766657869926,"stop":1766657869927,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0,"hasContent":false}],"attachments":[{"uid":"3ecea8ff6a3b6ce9","name":"API Response","source":"3ecea8ff6a3b6ce9.json","type":"application/json","size":478}],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":1,"attachmentStep":false,"stepsCount":2,"hasContent":true},{"name":"Изменить мем с id: 261","time":{"start":1766657869928,"stop":1766657870255,"duration":327},"status":"passed","steps":[{"name":"Статус-код 200","time":{"start":1766657870255,"stop":1766657870255,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0,"hasContent":false}],"attachments":[{"uid":"406efad77a5bb399","name":"API Response","source":"406efad77a5bb399.json","type":"application/json","size":595}],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":1,"attachmentStep":false,"stepsCount":1,"hasContent":true}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":2,"attachmentStep":false,"stepsCount":5,"hasContent":true}],"testStage":{"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)","statusTrace":"self = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n../local/lib/python3.11/site-packages/requests/models.py:976: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../local/lib/python3.11/json/__init__.py:346: in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n../local/lib/python3.11/json/decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7f2210ad0e50>\ns = '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\\n<title>500 Internal Server Error</title>\\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\\n'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/json/decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_memes_api.TestMemes object at 0x7f220ec79590>\npre_update_and_delete_meme = ResponseMemeModel(id=261, info={'names': ['Michelle Smith', 'Brianna Parker', 'Andrea Contreras'], 'phone_numbers': ['...ign help. Apply fly range although attention various court.', updated_by='Aleksei Mishin', url='https://phillips.com/')\n\n    @allure.feature('Изменение мема')\n    @allure.title('Повторно отредактированный мем должен отображаться в списке мемов')\n    @pytest.mark.medium\n    def test_re_updated_meme_should_be_in_memes_list(self, pre_update_and_delete_meme):\n        mem_id = pre_update_and_delete_meme.id\n        update_meme_resp = self.memes_api.update_meme(mem_id, payload.update_meme(mem_id))\n>       get_memes_resp = self.memes_api.get_all_memes()\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests/test_memes_api.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \napi_client/memes_api/memes_api.py:109: in get_all_memes\n    self.assertions.check_status_code_is_200(resp)\nassertions/base_assertions.py:10: in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Response [500]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError","steps":[{"name":"Изменить мем с id: 261","time":{"start":1766657870257,"stop":1766657870569,"duration":312},"status":"passed","steps":[{"name":"Статус-код 200","time":{"start":1766657870569,"stop":1766657870569,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0,"hasContent":false}],"attachments":[{"uid":"79655e9af649793f","name":"API Response","source":"79655e9af649793f.json","type":"application/json","size":614}],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":1,"attachmentStep":false,"stepsCount":1,"hasContent":true},{"name":"Вернуть все мемы","time":{"start":1766657870569,"stop":1766657870916,"duration":347},"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n","statusTrace":"  File \"/usr/workspace/api_client/memes_api/memes_api.py\", line 109, in get_all_memes\n    self.assertions.check_status_code_is_200(resp)\n  File \"/usr/workspace/assertions/base_assertions.py\", line 10, in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.11/site-packages/requests/models.py\", line 980, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n","steps":[{"name":"Статус-код 200","time":{"start":1766657870915,"stop":1766657870915,"duration":0},"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n","statusTrace":"  File \"/usr/workspace/assertions/base_assertions.py\", line 10, in check_status_code_is_200\n    f\"{response.json()}\")\n       ^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.11/site-packages/requests/models.py\", line 980, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0,"hasContent":true}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":1,"hasContent":true}],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"attachmentsCount":1,"attachmentStep":false,"stepsCount":4,"hasContent":true},"afterStages":[{"name":"pre_update_and_delete_meme::0","time":{"start":1766657870978,"stop":1766657871311,"duration":333},"status":"passed","steps":[{"name":"Удалить мем с id: 261","time":{"start":1766657870978,"stop":1766657871311,"duration":333},"status":"passed","steps":[{"name":"Статус-код 200","time":{"start":1766657871311,"stop":1766657871311,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0,"hasContent":false},{"name":"Отображается сообщение об успешном удалении мема","time":{"start":1766657871311,"stop":1766657871311,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0,"hasContent":false}],"attachments":[{"uid":"2427556c86e6f0ca","name":"API Response","source":"2427556c86e6f0ca.json","type":"application/json","size":39}],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":1,"attachmentStep":false,"stepsCount":2,"hasContent":true}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":1,"attachmentStep":false,"stepsCount":3,"hasContent":true},{"name":"_xunit_setup_method_fixture_TestMemes::0","time":{"start":1766657871312,"stop":1766657871312,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"attachmentsCount":0,"attachmentStep":false,"stepsCount":0,"hasContent":false}],"labels":[{"name":"suite","value":"Мемы"},{"name":"story","value":"API тесты"},{"name":"feature","value":"Изменение мема"},{"name":"tag","value":"medium"},{"name":"parentSuite","value":"tests"},{"name":"subSuite","value":"TestMemes"},{"name":"host","value":"e69444e30e92"},{"name":"thread","value":"15-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.test_memes_api"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":true,"retry":true,"extra":{"categories":[],"tags":["medium"]},"source":"1fbffffe6ab27753.json","parameterValues":[]}